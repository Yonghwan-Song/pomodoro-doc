---
sidebar_position: 9
---

# Miscellaneous

## IndexedDB 아키텍처: 다중 프로세스 접근 원리

웹 애플리케이션에서 `IndexedDB`는 `Service Worker` Process와 `Renderer` Process(메인 스레드가 실행되는 탭) 양쪽에서 모두 접근할 수 있는 유일한 영구 저장소입니다. 이러한 공유 접근이 가능한 이유는 `localStorage`와 근본적으로 다른 아키텍처 설계에 있습니다.

---

### 1. `localStorage`의 한계

`localStorage`는 서비스 워커 컨텍스트에서 사용할 수 없으며, 그 이유는 다음과 같습니다.

- **`window` 객체 종속성:** `localStorage`는 `window.localStorage` API를 통해 노출됩니다. `window` 객체는 `Renderer` Process(탭)에만 존재하는 전역 객체이며, `Service Worker` Process에는 `window` 객체가 존재하지 않아 접근이 원천적으로 불가능합니다.
- **동기(Synchronous) API:** `localStorage`는 동기식 API입니다. 만약 서비스 워커에서 이 API를 사용할 수 있게 허용한다면, 모든 백그라운드 작업을 처리하는 서비스 워커 스레드가 차단(blocking)되어 브라우저 전체의 성능에 심각한 영향을 미칠 수 있습니다.

---

### 2. `IndexedDB`의 아키텍처: IPC (프로세스 간 통신)

`IndexedDB`는 특정 프로세스의 메모리(Heap)에 저장되는 데이터가 아니며, 다음과 같은 브라우저의 핵심 아키텍처를 통해 작동합니다.

#### 1. 관리 주체: 브라우저 프로세스 (Browser Process)

`IndexedDB`의 실제 데이터는 사용자의 디스크(Disk)에 파일 형태(LevelDB)로 저장됩니다. 이 디스크 파일에 직접 접근하여 데이터를 읽고 쓰는 유일한 주체는 브라우저의 핵심인 **브라우저 프로세스(Browser Process)**입니다.

모든 탭(`Renderer` Process)과 서비스 워커(`Service Worker` Process)는 이 데이터를 직접 관리하지 않습니다.

#### 2. 접근 방식: 프로세스 간 통신 (IPC)

`Renderer` Process나 `Service Worker` Process에서 `indexedDB.open()` 같은 API를 호출할 때, 실제로는 해당 프로세스의 메모리에서 작업을 수행하는 것이 아닙니다.

1.  **비동기 요청:** `IndexedDB` API 호출은 브라우저의 저수준(low-level) **IPC(Inter-Process Communication)** 메커니즘을 통해 "브라우저 프로세스"에게 **비동기 메시지(Request)**를 전송합니다.
2.  **중앙 관리:** 브라우저 프로세스는 모든 프로세스(여러 탭, 서비스 워커)로부터 받은 요청을 **중앙 큐(Queue)**에서 순서대로 관리합니다. 트랜잭션과 파일 잠금(Lock)을 보장하며 안전하게 디스크의 데이터를 처리합니다.
3.  **비동기 응답:** 작업이 완료되면, 브라우저 프로세스는 다시 IPC를 통해 **결과 메시지(Response)**를 원래 **요청했던 프로세스**에게 돌려보냅니다.

#### 3. 이벤트 루프와 태스크 큐 (Event Loop & Task Queue)

브라우저 프로세스로부터 반환된 IPC 결과 메시지는 해당 프로세스(Renderer 또는 SW)의 **태스크 큐(Task Queue, Macrotask Queue)**에 등록됩니다.

그러면 해당 프로세스의 **이벤트 루프(Event Loop)**가 이 태스크를 발견하고, `onsuccess` 콜백 함수를 실행하거나 관련 `Promise`를 `resolve`시킵니다.

**결론적으로,** `IndexedDB`는 브라우저의 핵심인 **브라우저 프로세스**가 중앙에서 관리하는 디스크 기반 저장소입니다. 모든 컨텍스트(탭, 서비스 워커)는 오직 **비동기 IPC**라는 표준화된 통신 채널을 통해서만 접근을 "요청"하고 "응답"받기 때문에, 여러 프로세스 간에 데이터를 안전하게 공유할 수 있습니다.




---

## Service Worker의 수명 주기와 Web API (setInterval)

### 1. 문제의 배경: 역설(Paradox)

`setInterval`과 같은 Web API는 `Renderer` Process나 `Service Worker` Process의 메인 스레드에서 직접 실행되지 않고, 브라우저의 다른 스레드나 **`Browser` Process**에게 "위임"됩니다.

여기서 다음과 같은 논리적인 질문이 생깁니다.

> "Service Worker(SW) Process가 종료되더라도, 타이머를 위임받은 Browser Process는 살아있습니다. 그렇다면 왜 `setInterval`이 멈추는 것입니까? 타이머는 계속 돌고, 나중에 SW가 다시 살아났을 때 밀린 콜백을 처리해야 하는 것 아닙니까?"

이 질문의 답은 **Task Queue(작업 큐)가 작동하는 방식**에 있습니다.

---

### 2. 핵심 원리: Task Queue는 프로세스에 종속적입니다.

`Task Queue`(이벤트 큐)는 브라우저 전체에 하나만 존재하는 "공용 큐"가 아닙니다.

- **`Renderer` Process (탭 1)**는 **"탭 1 전용 Task Queue"**를 가집니다.
- **`Renderer` Process (탭 2)**는 **"탭 2 전용 Task Queue"**를 가집니다.
- **`Service Worker` Process**는 **"SW 전용 Task Queue"**를 가집니다.

Web API에게 작업을 위임한다는 것은 "그냥 실행해"가 아니라, "**작업이 끝나면 *나의 전용 Task Queue*에 콜백을 넣어줘**"라는 의미입니다.

---

### 3. `setInterval`이 멈추는 정확한 순서

1.  **[SW Process]** `setInterval(myCallback, 1000)`을 호출합니다.

    - 이것은 `Browser` Process(중앙 타이머 관리자)에게 보내는 요청입니다.
    - **요청 내용:** "1초마다 `myCallback`을 ***SW 전용 Task Queue*에** 배달해주세요."

2.  **[Browser Process]** "알겠습니다." (타이머 시작)

3.  **[SW Process]** 현재 처리 중이던 이벤트(예: `install` 또는 `activate`)를 완료하고 **"유휴(Idle)"** 상태가 됩니다.

4.  **[Browser Process]** `Service Worker`는 리소스 절약을 위해 "이벤트 기반"으로 작동하도록 설계되었습니다. `Browser` Process는 SW가 유휴 상태인 것을 확인하고, **`Service Worker` Process를 강제로 종료(Kill)시킵니다.**

5.  **[SW Process]** 프로세스가 종료되면서, 이 프로세스에 속해있던 **Call Stack, Heap, 그리고 *"SW 전용 Task Queue"*가 모두 메모리에서 사라집니다.**

6.  **[Browser Process]** (1초 뒤) "약속대로 `myCallback`을 ***SW 전용 Task Queue*에** 배달해야지."

7.  **[Browser Process]** "...어? 배달할 주소(SW 전용 Task Queue)가 **존재하지 않습니다.**"

8.  **[Browser Process]** 배달 대상을 잃은 타이머는 작업을 중단하거나 취소됩니다.

> #### 🍕 피자 배달 비유
>
> `setInterval`은 10분마다 피자(`myCallback`)를 **"A사무실"**(`SW Process`)로 배달해달라고 주문하는 것과 같습니다.
>
> "A사무실"이 갑자기 폐업해서 사라졌습니다.
>
> 피자 배달부(`Browser` Process의 타이머)는 10분 뒤 "A사무실"에 도착했지만, 사무실 자체가 사라진 것을 확인합니다. 배달부는 피자를 버리고(작업 취소), 더 이상 "A사무실"로 배달을 오지 않습니다.

**결론:** `setInterval`은 `Service Worker`의 수명을 연장해주지 못합니다. Web API(타이머)가 멈추는 것이 아니라, 콜백을 **전달받을 대상(Task Queue)**이 프로세스 종료와 함께 **사라지기(demolished)** 때문에 멈추는 것입니다.

---

### 4. 핵심 출처 (Sources)

- **1. Service Worker의 수명 주기 (MDN):**
  - [https://developer.mozilla.org/ko/docs/Web/API/Service_Worker_API/Service_worker_concepts](https://developer.mozilla.org/ko/docs/Web/API/Service_Worker_API/Service_worker_concepts)
  - **내용:** 이 문서, 특히 '수명 주기(Lifecycle)' 섹션에서는 서비스 워커가 이벤트를 처리하지 않을 때 **"유휴(idle)" 상태가 되고 결국 "종료(terminated)"**된다고 명시하고 있습니다. `setInterval`은 이 수명을 연장시키는 "이벤트"로 간주되지 않습니다.

- **2. 이벤트 루프와 태스크 큐 (MDN):**
  - [https://developer.mozilla.org/ko/docs/Web/JavaScript/EventLoop](https://developer.mozilla.org/ko/docs/Web/JavaScript/EventLoop)
  - **내용:** 이 문서는 Web API(예: `setInterval`)의 콜백이 어떻게 **"태스크 큐(Task Queue)"**를 통해 처리되는지 설명합니다. 우리가 논의한 "배달 주소"가 바로 이 큐이며, 이 큐는 프로세스와 생명 주기를 함께합니다.

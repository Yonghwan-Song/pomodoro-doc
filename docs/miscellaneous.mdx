---
sidebar_position: 9
---

# Miscellaneous

## IndexedDB 아키텍처: 다중 프로세스 접근 원리

웹 애플리케이션에서 `IndexedDB`는 `Service Worker` Process와 `Renderer` Process(메인 스레드가 실행되는 탭) 양쪽에서 모두 접근할 수 있는 유일한 영구 저장소입니다. 이러한 공유 접근이 가능한 이유는 `localStorage`와 근본적으로 다른 아키텍처 설계에 있습니다.

---

### 1. `localStorage`의 한계

`localStorage`는 서비스 워커 컨텍스트에서 사용할 수 없으며, 그 이유는 다음과 같습니다.

- **`window` 객체 종속성:** `localStorage`는 `window.localStorage` API를 통해 노출됩니다. `window` 객체는 `Renderer` Process(탭)에만 존재하는 전역 객체이며, `Service Worker` Process에는 `window` 객체가 존재하지 않아 접근이 원천적으로 불가능합니다.
- **동기(Synchronous) API:** `localStorage`는 동기식 API입니다. 만약 서비스 워커에서 이 API를 사용할 수 있게 허용한다면, 모든 백그라운드 작업을 처리하는 서비스 워커 스레드가 차단(blocking)되어 브라우저 전체의 성능에 심각한 영향을 미칠 수 있습니다.

---

### 2. `IndexedDB`의 아키텍처: IPC (프로세스 간 통신)

`IndexedDB`는 특정 프로세스의 메모리(Heap)에 저장되는 데이터가 아니며, 다음과 같은 브라우저의 핵심 아키텍처를 통해 작동합니다.

#### 1. 관리 주체: 브라우저 프로세스 (Browser Process)

`IndexedDB`의 실제 데이터는 사용자의 디스크(Disk)에 파일 형태(LevelDB)로 저장됩니다. 이 디스크 파일에 직접 접근하여 데이터를 읽고 쓰는 유일한 주체는 브라우저의 핵심인 **브라우저 프로세스(Browser Process)**입니다.

모든 탭(`Renderer` Process)과 서비스 워커(`Service Worker` Process)는 이 데이터를 직접 관리하지 않습니다.

#### 2. 접근 방식: 프로세스 간 통신 (IPC)

`Renderer` Process나 `Service Worker` Process에서 `indexedDB.open()` 같은 API를 호출할 때, 실제로는 해당 프로세스의 메모리에서 작업을 수행하는 것이 아닙니다.

1.  **비동기 요청:** `IndexedDB` API 호출은 브라우저의 저수준(low-level) **IPC(Inter-Process Communication)** 메커니즘을 통해 "브라우저 프로세스"에게 **비동기 메시지(Request)**를 전송합니다.
2.  **중앙 관리:** 브라우저 프로세스는 모든 프로세스(여러 탭, 서비스 워커)로부터 받은 요청을 **중앙 큐(Queue)**에서 순서대로 관리합니다. 트랜잭션과 파일 잠금(Lock)을 보장하며 안전하게 디스크의 데이터를 처리합니다.
3.  **비동기 응답:** 작업이 완료되면, 브라우저 프로세스는 다시 IPC를 통해 **결과 메시지(Response)**를 원래 **요청했던 프로세스**에게 돌려보냅니다.

#### 3. 이벤트 루프와 태스크 큐 (Event Loop & Task Queue)

브라우저 프로세스로부터 반환된 IPC 결과 메시지는 해당 프로세스(Renderer 또는 SW)의 **태스크 큐(Task Queue, Macrotask Queue)**에 등록됩니다.

그러면 해당 프로세스의 **이벤트 루프(Event Loop)**가 이 태스크를 발견하고, `onsuccess` 콜백 함수를 실행하거나 관련 `Promise`를 `resolve`시킵니다.

**결론적으로,** `IndexedDB`는 브라우저의 핵심인 **브라우저 프로세스**가 중앙에서 관리하는 디스크 기반 저장소입니다. 모든 컨텍스트(탭, 서비스 워커)는 오직 **비동기 IPC**라는 표준화된 통신 채널을 통해서만 접근을 "요청"하고 "응답"받기 때문에, 여러 프로세스 간에 데이터를 안전하게 공유할 수 있습니다.




---

## Service Worker의 수명 주기와 Web API (setInterval)

### 1. 문제의 배경: 역설(Paradox)

`setInterval`과 같은 Web API는 `Renderer` Process나 `Service Worker` Process의 메인 스레드에서 직접 실행되지 않고, 브라우저의 다른 스레드나 **`Browser` Process**에게 "위임"됩니다.

여기서 다음과 같은 논리적인 질문이 생깁니다.

> "Service Worker(SW) Process가 종료되더라도, 타이머를 위임받은 Browser Process는 살아있습니다. 그렇다면 왜 `setInterval`이 멈추는 것입니까? 타이머는 계속 돌고, 나중에 SW가 다시 살아났을 때 밀린 콜백을 처리해야 하는 것 아닙니까?"

이 질문의 답은 **Task Queue(작업 큐)가 작동하는 방식**에 있습니다.

---

### 2. 핵심 원리: Task Queue는 프로세스에 종속적입니다.

`Task Queue`(이벤트 큐)는 브라우저 전체에 하나만 존재하는 "공용 큐"가 아닙니다.

- **`Renderer` Process (탭 1)**는 **"탭 1 전용 Task Queue"**를 가집니다.
- **`Renderer` Process (탭 2)**는 **"탭 2 전용 Task Queue"**를 가집니다.
- **`Service Worker` Process**는 **"SW 전용 Task Queue"**를 가집니다.

Web API에게 작업을 위임한다는 것은 "그냥 실행해"가 아니라, "**작업이 끝나면 *나의 전용 Task Queue*에 콜백을 넣어줘**"라는 의미입니다.

---

### 3. `setInterval`이 멈추는 정확한 순서

1.  **[SW Process]** `setInterval(myCallback, 1000)`을 호출합니다.

    - 이것은 `Browser` Process(중앙 타이머 관리자)에게 보내는 요청입니다.
    - **요청 내용:** "1초마다 `myCallback`을 ***SW 전용 Task Queue*에** 배달해주세요."

2.  **[Browser Process]** "알겠습니다." (타이머 시작)

3.  **[SW Process]** 현재 처리 중이던 이벤트(예: `install` 또는 `activate`)를 완료하고 **"유휴(Idle)"** 상태가 됩니다.

4.  **[Browser Process]** `Service Worker`는 리소스 절약을 위해 "이벤트 기반"으로 작동하도록 설계되었습니다. `Browser` Process는 SW가 유휴 상태인 것을 확인하고, **`Service Worker` Process를 강제로 종료(Kill)시킵니다.**

5.  **[SW Process]** 프로세스가 종료되면서, 이 프로세스에 속해있던 **Call Stack, Heap, 그리고 *"SW 전용 Task Queue"*가 모두 메모리에서 사라집니다.**

6.  **[Browser Process]** (1초 뒤) "약속대로 `myCallback`을 ***SW 전용 Task Queue*에** 배달해야지."

7.  **[Browser Process]** "...어? 배달할 주소(SW 전용 Task Queue)가 **존재하지 않습니다.**"

8.  **[Browser Process]** 배달 대상을 잃은 타이머는 작업을 중단하거나 취소됩니다.

> #### 🍕 피자 배달 비유
>
> `setInterval`은 10분마다 피자(`myCallback`)를 **"A사무실"**(`SW Process`)로 배달해달라고 주문하는 것과 같습니다.
>
> "A사무실"이 갑자기 폐업해서 사라졌습니다.
>
> 피자 배달부(`Browser` Process의 타이머)는 10분 뒤 "A사무실"에 도착했지만, 사무실 자체가 사라진 것을 확인합니다. 배달부는 피자를 버리고(작업 취소), 더 이상 "A사무실"로 배달을 오지 않습니다.

**결론:** `setInterval`은 `Service Worker`의 수명을 연장해주지 못합니다. Web API(타이머)가 멈추는 것이 아니라, 콜백을 **전달받을 대상(Task Queue)**이 프로세스 종료와 함께 **사라지기(demolished)** 때문에 멈추는 것입니다.

---

### 4. 핵심 출처 (Sources)

- **1. Service Worker의 수명 주기 (MDN):**

  - [https://developer.mozilla.org/ko/docs/Web/API/Service_Worker_API/Service_worker_concepts](https://developer.mozilla.org/ko/docs/Web/API/Service_Worker_API/Service_worker_concepts)
  - **내용:** 이 문서, 특히 '수명 주기(Lifecycle)' 섹션에서는 서비스 워커가 이벤트를 처리하지 않을 때 **"유휴(idle)" 상태가 되고 결국 "종료(terminated)"**된다고 명시하고 있습니다. `setInterval`은 이 수명을 연장시키는 "이벤트"로 간주되지 않습니다.

- **2. 이벤트 루프와 태스크 큐 (MDN):**
  - [https://developer.mozilla.org/ko/docs/Web/JavaScript/EventLoop](https://developer.mozilla.org/ko/docs/Web/JavaScript/EventLoop)
  - **내용:** 이 문서는 Web API(예: `setInterval`)의 콜백이 어떻게 **"태스크 큐(Task Queue)"**를 통해 처리되는지 설명합니다. 우리가 논의한 "배달 주소"가 바로 이 큐이며, 이 큐는 프로세스와 생명 주기를 함께합니다.

<!-- ## JavaScript Runtime and Execution Model -->
<!-- ## How I Understand the JavaScript Execution Flow -->

## “자바스크립트 런타임과 실행 메커니즘에 대한 정리 (JavaScript Runtime & Execution Mechanism Notes)”
### JavaScript Runtime이란?

#### 🔹 정의
**Runtime**이란 프로그램이 실제로 실행되는 시점과 그 실행 환경 전체를 의미한다.  
즉, **코드가 살아 움직이는 순간과 그걸 가능하게 하는 시스템**을 통틀어 부르는 말이다.

> 💡 **Runtime = 실행 중인 프로그램 + 그 실행을 가능하게 하는 엔진/환경**

---

#### ⚙️ JavaScript Runtime 구성 요소

| 구성 요소 | 설명 |
|------------|------|
| **JS 엔진 (V8, SpiderMonkey 등)** | JavaScript 코드를 파싱하고 바이트코드로 컴파일해 실행하는 핵심 엔진. |
| **메모리 힙 (Memory Heap)** | 객체, 함수, 클로저 등 데이터가 실제로 저장되는 공간. |
| **콜 스택 (Call Stack)** | 현재 실행 중인 함수들의 실행 컨텍스트(Execution Context)를 관리. |
| **호스트 환경 API** | 브라우저 또는 Node.js가 제공하는 기능 (예: `setTimeout`, `fetch`, `DOM` 등). |
| **이벤트 루프 (Event Loop)** | 콜 스택이 비면 대기 중인 작업(콜백, 프로미스 등)을 큐에서 꺼내 실행. |
| **Task Queue / Microtask Queue** | 비동기 작업을 일시적으로 보관하는 큐. |

> 🧠 즉, **JavaScript Runtime = JS 엔진 + 호스트 환경(API, Event Loop 등)**  
> → JS 코드가 실제로 실행되는 전체 생태계.

---

#### ⏱️ Compile Time vs Runtime

| 시점 | 설명 |
|------|------|
| **Compile Time (준비기)** | 코드가 해석되고 실행 전 구조를 세팅하는 단계 (렉시컬 환경 구성 등). |
| **Runtime (실행기)** | 코드가 실제로 실행되어 값이 생성되고, 호출 스택이 움직이는 실시간 과정. |

> 예: `function foo()`를 **정의**하는 건 compile time,  
> `foo()`를 **호출**하는 순간부터 runtime이 시작된다.

---

#### 🧩 비유로 이해하기
- **Compile Time** → “무대 세팅”  
- **Runtime** → “배우가 실제로 연기하며 스토리가 진행되는 순간”  
- 코드가 동작하고, 변수가 값으로 살아 있는 그 순간이 바로 **Runtime**이다.

---

#### 🔧 요약
- **Runtime**: 코드가 실행되는 “살아 있는 시간대 + 환경”.  
- **JavaScript Runtime**: V8 엔진 + 이벤트 루프 + API 시스템의 조합.  
- **핵심 개념**: *“코드가 실제로 움직이는 순간과 그 생태계 전체를 말한다.”*


---


---

### JavaScript 런타임에 대한 멘탈 모델 형성해보기

목차는 가장 '물리적인(낮은 수준)' 개념에서 시작하여 가장 '추상적인(높은 수준)' 개념으로 나아가도록 구성했습니다.

1.  **Part 1: 메모리 모델 (Stack & Heap)과 값의 복사**
    * 원시 타입 vs 참조 타입
    * "값에 의한 복사" vs "참조에 의한 복사"의 진실
2.  **Part 2: 렉시컬 환경 (Lexical Environment) - '스코프'의 실체**
    * 명세(Spec)상의 정의: 2가지 구성 요소
    * V8 엔진의 실제 구현: Fast Path vs Slow Path (Context 객체)
3.  **Part 3: 실행 컨텍스트 (Execution Context) - '실행'의 주체**
    * 3가지 구성 요소 (LE, VE, ThisBinding)
    * 3가지 종류 (GEC, FEC, MEC)
4.  **Part 4: 핵심 메커니즘 1 - 호이스팅 (Hoisting)**
    * 생성 단계(Creation Phase)의 비밀
    * `var`, `let/const`, `function`의 차이 (TDZ)
5.  **Part 5: 핵심 메커니즘 2 - `this` 바인딩**
    * `this`가 필요한 이유
    * EC 종류별 `this` (GEC, MEC)
    * FEC의 4가지 `this` 결정 규칙 (및 우선순위)
    * 예외: 화살표 함수 (Lexical `this`)
6.  **Part 6: 핵심 메커니즘 3 - 클로저 (Closure)**
    * 클로저의 정의
    * 클로저의 작동 원리 (Function Object와 `[[Environment]]`)
7.  **Part 7: 핵심 메커니즘 4 - 모듈 시스템 (ESM)**
    * 모듈 스코프 (MEC)
    * CJS vs ESM (Node.js vs 브라우저)
    * `import/export`와 '라이브 바인딩(Live Binding)'의 실체
    * 트리 쉐이킹(Tree Shaking)과의 연결
8.  **Part 8: 기타 주요 용어 정리**
    * Snapshot (스냅샷)
    * 정적(Static) vs 동적(Dynamic)

---

#### ## 1. 메모리 모델 (Stack & Heap)과 값의 복사

JS 엔진이 변수를 어떻게 다루는지 이해하는 가장 근본적인 모델입니다.

##### 🧠 Stack vs Heap

* **스택 (Stack):** 함수 호출, 지역 변수, 원시 타입 값, 메모리 주소(포인터) 등 크기가 고정되고 순서가 명확한 데이터를 저장합니다. 접근 속도가 매우 빠릅니다. 함수가 호출되면 '스택 프레임'이 쌓이고(push), 함수가 종료되면 사라집니다(pop).
* **힙 (Heap):** 객체(Object), 배열(Array), 함수(Function) 등 크기가 유동적이고 복잡한 데이터를 저장하는 거대한 메모리 공간입니다. 스택보다 속도가 느리지만, 데이터의 생명 주기를 더 유연하게 관리할 수 있습니다.

##### 📋 원시 타입 (Primitive) vs 참조 타입 (Reference)

* **원시 타입:** `string`, `number`, `boolean`, `null`, `undefined`, `symbol`.
* **참조 타입:** `Object` (및 `Array`, `Function`, `Map` 등 객체를 기반으로 하는 모든 것).

##### 🔑 "단 하나의 복사 규칙"

"Copy by Value"와 "Copy by Reference"라는 용어는 종종 혼란을 야기합니다. 사실 JS의 할당(`=`) 메커니즘은 **단 하나**입니다.

> **"모든 할당(`=`)은 스택(슬롯)에 있는 값을 그대로 복사(Copy)한다."**

이 규칙 하나로 모든 것이 설명됩니다. 차이점은 "스택에 무엇이 들어있었는가"입니다.

* **"값에 의한 복사" (Copy by Value)가 일어나는 경우 (원시 타입)**
    1.  `let a = 10;`
        * 엔진이 스택에 `a`를 위한 슬롯(공간)을 만들고, 그 슬롯에 **값 `10` 자체**를 저장합니다.
    2.  `let b = a;`
        * 엔진이 스택에 `b`를 위한 새 슬롯을 만들고, `a`의 슬롯에 있던 **값 `10`을 복사**해서 넣습니다.
    3.  `b = 20;`
        * `b` 슬롯의 값을 `20`으로 바꿉니다. `a` 슬롯에는 아무 영향이 없습니다.
    * **결과:** `a`와 `b`는 완전히 독립적인 값을 가집니다.

* **"참조에 의한 복사" (Copy by Reference)가 일어나는 경우 (참조 타입)**
    1.  `let obj1 = { val: 10 };`
        * 엔진이 `{ val: 10 }` 객체를 **힙(Heap)**에 생성합니다 (주소: `0xABC`).
        * 엔진이 스택에 `obj1`을 위한 슬롯을 만들고, 그 슬롯에 **힙 주소 `0xABC`**를 저장합니다.
    2.  `let obj2 = obj1;`
        * 엔진이 스택에 `obj2`를 위한 새 슬롯을 만들고, `obj1`의 슬롯에 있던 **힙 주소 `0xABC`를 복사**해서 넣습니다.
    3.  `obj2.val = 20;`
        * 엔진이 `obj2`의 슬롯에서 `0xABC` 주소를 읽고, 힙으로 찾아가서 `{ val: 20 }`으로 변경합니다.
    * **결과:** `obj1`과 `obj2`는 **동일한 힙 주소**를 가리키므로, 하나의 객체를 공유합니다. `obj1.val`을 봐도 `20`이 보입니다.

---

#### ## 2. 렉시컬 환경 (Lexical Environment) - '스코프'의 실체

"스코프(Scope)"라는 추상적인 '규칙'을 물리적으로 구현하는 '객체(저장소)'입니다.

##### 📜 명세(Spec)상의 정의

ECMAScript 명세(설계도)에 따르면, `Lexical Environment` (LE)는 2가지 구성 요소를 가진 **추상적인 개념**입니다.

1.  **환경 레코드 (Environment Record):**
    * `let`, `const`, `function` 등으로 선언된 변수와 함수를 'Key-Value' 형태로 **실제로 저장하는 저장소**입니다. (e.g., `{ a: 10, b: <uninitialized> }`)
2.  **외부 환경 참조 (Outer Environment Reference):**
    * **부모 스코프(상위 LE)를 가리키는 포인터(링크)**입니다.
    * 이 참조가 꼬리에 꼬리를 물고 연결된 것을 **"스코프 체인(Scope Chain)"**이라고 부릅니다.
    * JS 엔진이 변수를 찾을 때, 현재 LE의 환경 레코드에 없으면 이 참조를 타고 부모 LE로 올라가서 찾습니다.

##### 🚀 V8 엔진의 실제 구현 (중요)

V8 엔진은 이 'LE'라는 개념을 **최적화**를 위해 두 가지 방식으로 구현합니다.

* **Fast Path (최적화 경로):**
    * 만약 함수 내의 변수들이 **클로저에 의해 참조되지 않는다면**, V8은 굳이 LE 객체를 만들지 않습니다.
    * 변수들은 **스택 프레임(Stack Frame)에 직접 생성**됩니다. 함수가 끝나면 스택 프레임과 함께 한 번에 사라지므로(pop) 매우 빠릅니다.
    * 이 경우 "LE = 스택 프레임 그 자체"입니다.

* **Slow Path (클로저 발생 시):**
    * 만약 함수 내의 변수가 **내부 함수(클로저)에 의해 참조**된다면, 이 변수는 **함수가 종료된 후에도 살아남아야 합니다.**
    * 스택은 함수 종료 시 사라지므로, V8은 이 변수들을 스택에 두지 않습니다.
    * 대신, **`Context`**라는 특별한 객체를 **힙(Heap)에 생성**하고, 클로저가 참조하는 변수들(e.g., `count`)을 이 `Context` 객체 안에 저장합니다.
    * 이 **힙(Heap)에 생성된 `Context` 객체**가 바로 LE의 '물리적인 실체'입니다.
    * (이것이 클로저가 작동하는 핵심 원리입니다. Part 6에서 자세히 설명)

---

#### ## 3. 실행 컨텍스트 (Execution Context) - '실행'의 주체

LE가 '환경(지도/변수 저장소)'이라면, `Execution Context` (EC)는 그 환경에서 코드를 '실행하는 주체(프로세스/작업)'입니다. 코드가 실행될 때마다 `Call Stack`에 쌓입니다.

##### 🧩 3가지 구성 요소

ECMAScript 명세에 따르면, EC는 3가지 요소를 가집니다.

1.  **`LexicalEnvironment` (LE):**
    * `let`, `const`, `function` 선언을 저장하고 관리합니다.
    * EC가 `{}` 블록 스코프에 진입/탈출할 때마다, EC가 가리키는 `LE` 포인터는 **새로운 '블록 LE'로 교체**됩니다. (이것이 `let`/`const`가 블록 스코프를 갖는 이유)
2.  **`VariableEnvironment` (VE):**
    * **오직 `var` 선언**만을 저장합니다.
    * EC가 생성될 때 한 번 만들어지고, `{}` 블록을 만나도 **절대 변하지 않습니다.** (이것이 `var`가 함수 스코프를 갖는 이유)
3.  **`ThisBinding`:**
    * 이 EC 내부에서 `this` 키워드가 가리킬 객체의 **참조(주소)**를 저장합니다.

##### 🏭 3가지 종류

실무에서 알아야 할 EC는 3가지입니다.

1.  **`GEC` (Global Execution Context):**
    * JS 엔진이 코드를 실행하기 위해 맨 처음 생성하는 기반 컨텍스트. (콜 스택의 맨 바닥)
    * `this` 바인딩: 브라우저에서는 `window`, Node.js(CJS)에서는 `global` 객체.
2.  **`FEC` (Function Execution Context):**
    * **함수가 '호출'될 때마다** 매번 새롭게 생성됩니다.
    * `this` 바인딩: "어떻게 호출되었는가"에 따라 (Part 5의) 4가지 규칙 중 하나가 적용됩니다.
3.  **`MEC` (Module Execution Context):**
    * `import/export`를 사용하는 **ES 모듈 파일**을 실행할 때 생성됩니다.
    * `this` 바인딩: **`undefined`**로 고정됩니다.
    * (React 컴포넌트 파일 최상단에서 `this`를 찍으면 `undefined`가 나오는 이유입니다.)

---

#### ## 4. 핵심 메커니즘 1 - 호이스팅 (Hoisting)

호이스팅은 "선언을 끌어올린다"는 비유가 아니라, **"EC의 생성 단계(Creation Phase)에서 선언부를 미리 처리한다"**는 엔진의 동작 원리입니다.

함수가 호출되면, 코드를 한 줄씩 실행하는 **'실행 단계(Execution Phase)'** 전에, 함수 전체를 스캔하는 **'생성 단계(Creation Phase)'**가 먼저 일어납니다.

| 키워드 | 저장소 (어디에) | '생성 단계' 초기화 (어떻게) | TDZ (결과) |
| :--- | :--- | :--- | :--- |
| **`var`** | **VE** (VariableEnvironment) | **`undefined`** | **없음 (X)** |
| **`let`** | **LE** (LexicalEnvironment) | `<uninitialized>` (초기화 안 됨) | **있음 (O)** |
| **`const`** | **LE** (LexicalEnvironment) | `<uninitialized>` (초기화 안 됨) | **있음 (O)** |
| **`function`** | **LE** (LexicalEnvironment) | **'함수 객체' (즉시)** | **없음 (X)** |

* **`var`:** 생성 단계에서 `VE`에 등록되고 `undefined`로 즉시 초기화됩니다. 그래서 선언 전에 호출해도 에러가 안 나고 `undefined`가 나옵니다.
* **`let/const`:** 생성 단계에서 `LE`에 `<uninitialized>` 상태로 등록됩니다. 이 "스코프 시작점 ~ 실제 선언 라인"까지의 '접근 금지 구간'을 **TDZ (Temporal Dead Zone)**라고 부릅니다. 이 구간에서 접근 시 `ReferenceError`가 발생합니다.
* **`function`:** 생성 단계에서 `LE`에 등록됨과 **동시에** '완성된 함수 객체'(힙 주소)로 즉시 초기화됩니다. 그래서 선언 전에 호출해도 완벽하게 동작합니다.

---

#### ## 5. 핵심 메커니즘 2 - `this` 바인딩

`this`는 "함수의 '재사용성'을 위해, 함수에게 '실행 맥락(주인공 객체)'을 알려주는 **암시적 매개변수**"입니다.

##### 🎯 EC 종류별 `this` (요약)

* `GEC`: `window` (브라우저) 또는 `global` (Node CJS)
* `MEC`: `undefined`

##### 🎯 FEC의 4가지 `this` 결정 규칙 (우선순위 순)

`FEC`의 `this`는 함수가 "어떻게 호출"되었는지에 따라 동적으로 결정됩니다.

1.  **`new` 바인딩 (생성자 호출):**
    * `new Person()`처럼 `new`로 호출하면, `this`는 **새로 생성되는 객체 인스턴스**가 됩니다.
2.  **명시적 바인딩 (Explicit Binding):**
    * `myFunc.call(obj)`, `myFunc.apply(obj)`, `myFunc.bind(obj)`
    * `call`, `apply`, `bind`의 **첫 번째 인자로 넘겨준 객체**가 `this`로 강제 지정됩니다.
3.  **암시적 바인딩 (Implicit Binding / 메소드 호출):**
    * `person.sayName()`처럼 **'점(.)'**을 찍어 객체의 메소드로 호출하면, `this`는 **그 '점(.)' 앞의 객체** (`person`)가 됩니다.
4.  **기본 바인딩 (Default Binding):**
    * 위 3가지가 아닌, `sayName()`처럼 '그냥' 호출되면 `this`는 기본값이 됩니다.
    * **Strict Mode (엄격 모드) / MEC:** `undefined`
    * **Non-Strict Mode (일반 모드):** `window` (전역 객체)

> **[함정] 콜백 함수와 `this`**
> `setTimeout(person.sayName, 100)`처럼 콜백으로 함수를 넘기면, `person` 객체와 분리되어 '함수 자체'만 넘어갑니다. `setTimeout`은 나중에 이 함수를 '그냥' 호출(규칙 4)하므로 `this`는 `window`가 됩니다. (이것이 `this` 관련 버그의 주원인입니다.)

##### ⚠️ 예외: 화살표 함수 (`=>`)

화살표 함수는 위 4가지 규칙을 **모두 무시**합니다.

* 화살표 함수의 `FEC`는 **`ThisBinding` 구성요소 자체가 아예 생성되지 않습니다.**
* 화살표 함수 내부에서 `this`를 사용하면, `this`는 '특별한 키워드'가 아닌 **'일반 변수'**처럼 취급됩니다.
* 엔진은 `this`를 찾기 위해 **스코프 체인(Outer Reference)을 타고 부모 스코프로 올라갑니다.**
* 결과적으로 화살표 함수의 `this`는 **"이 함수가 *선언(정의)될* 당시의 외부(부모) 스코프"**의 `this`를 그대로 물려받습니다. (이를 **Lexical `this`**라고 합니다.)

---

#### ## 6. 핵심 메커니즘 3 - 클로저 (Closure)

클로저는 `this`와 함께 JS의 가장 중요한 핵심 개념입니다.

##### 📜 정의

* **클로저(Closure):** "자신이 **정의(선언)된** 시점의 렉시컬 환경(LE)을 **기억(참조)**하는 함수"
* **현상:** 이로 인해, 외부 함수가 실행을 마치고 콜 스택에서 사라진 후에도, 그 외부 함수의 변수에 계속 접근할 수 있는 현상.

##### ⚙️ 작동 원리 (모든 개념의 총집합)

1.  **'탄생' (함수 정의 시점):**
    * `outer` 함수 안에서 `inner` 함수가 **정의**될 때, `inner`의 **`Function Object` (함수 객체)**가 **힙(Heap)**에 생성됩니다.
2.  **'출생지 기록' (`[[Environment]]`):**
    * 이 `Function Object`는 `[[Environment]]` (또는 `[[Scope]]`)라는 숨겨진 내부 슬롯(포인터)을 가집니다.
    * 이 슬롯에는 `inner` 함수가 '탄생'한 곳, 즉 **`outer` 함수의 `LE`를 가리키는 참조(주소)**가 저장됩니다.
3.  **'Slow Path' 발동:**
    * V8 엔진은 `inner`가 `outer`의 변수(e.g., `count`)를 참조하는 것을 감지합니다.
    * 엔진은 `count` 변수를 스택(Fast Path)이 아닌, **힙(Heap)의 `Context` 객체** (Slow Path)에 생성하여 `outer`의 `LE`를 구현합니다.
4.  **`outer` 함수 종료:**
    * `outer` 함수가 `inner` 함수를 `return`하고 콜 스택에서 pop되어 사라집니다.
    * `outer`의 스택 프레임은 사라졌지만, `outer`의 `LE` (즉, 힙에 있는 `Context` 객체)는 **사라지지 않습니다.**
    * **이유:** `return`된 `inner` 함수 객체가 `[[Environment]]` 슬롯으로 여전히 `Context` 객체를 **'참조'**하고 있기 때문에, 가비지 컬렉터(GC)가 수거해가지 않습니다.
5.  **`inner` 함수 호출 (나중):**
    * `inner` 함수가 호출되어 `FEC`가 생성됩니다.
    * `inner`의 `FEC`는 자신의 `LE`를 만들고, 'Outer Environment Reference'를 설정해야 합니다.
    * 이때, `inner` 함수 객체의 `[[Environment]]` 슬롯을 확인하여 "아, 나의 부모는 힙에 있는 저 `Context` 객체구나!"라고 인지하고 스코프 체인을 연결합니다.
    * 따라서 `inner`는 힙에 살아있는 `count` 변수에 접근할 수 있습니다.

---

#### ## 7. 핵심 메커니즘 4 - 모듈 시스템 (ESM)

현대 JS(React)는 '모듈' 기반으로 동작합니다.

##### 📦 Node.js (듀얼 시스템)

* `package.json`에 `"type": "module"`이 있거나 `.mjs` 확장자: **ESM** (ES 모듈) 방식
* 기본값 또는 `.cjs` 확장자: **CommonJS (CJS)** 방식
* **CJS의 `this`:** Node.js는 CJS 파일을 실행할 때 `(function(exports, require, module, __filename, __dirname) { ... })`라는 **래퍼(Wrapper) 함수**로 감쌉니다. 그리고 `this`를 `module.exports` (초기값: `{}`)로 바인딩합니다. (이것이 Node CJS 파일 최상단 `this`가 `{}`인 이유)

##### 🖥️ 브라우저 (듀얼 시스템)

* `<script type="module" ...>`: **ESM** 방식 (Module Scope, 최상위 `this`는 `undefined`)
* `<script ...>` (기본값): **Classic Script** 방식 (Global Scope, 최상위 `this`는 `window`)
* **번들러(Webpack)의 역할:** 개발 시에는 ESM (`import/export`) 문법을 사용하지만, `npm run build`를 하면 Webpack이 모든 `import`를 분석하여 **하나의 거대한 'Classic Script'** (`bundle.js`)로 합쳐줍니다. 이 파일은 `import` 구문이 없으므로 `type="module"` 없이도 구형 브라우저에서 잘 동작합니다.

##### 🔗 `import/export`와 '라이브 바인딩 (Live Binding)'

`import`는 값을 복사하는 것이 아닙니다.

1.  `A.js`가 `export let count = 10;`을 합니다.
    * `count`는 `A.js`의 `MEC`가 관리하는 `LE` (힙 `Context`)에 `10`이라는 값으로 저장됩니다 (주소: `0xABC`).
2.  `B.js`가 `import { count } from './A.js';`를 합니다.
    * `B.js`의 `LE`에 `count`라는 **새로운 바인딩(슬롯)**이 생깁니다.
    * 이 슬롯에는 `10`이 복사되는 것이 아니라, `A.js`에 있는 `count`의 **실제 메모리 주소(`0xABC`)를 가리키는 포인터(참조)**가 저장됩니다.
    * 이 포인터는 **읽기 전용(read-only)**입니다. (그래서 `import`한 변수에 재할당이 안 됨)
3.  **"라이브"의 의미:** 나중에 `A.js`가 `count = 20;`으로 값을 변경하면(`0xABC` 슬롯의 값이 바뀜), `B.js`는 `0xABC`를 바라보고 있으므로 **변경된 값 `20`을 실시간으로** 보게 됩니다.
4.  **`as`의 의미:** `import { count as myCount }`는 "내(`B.js`) `LE`에 `myCount`라는 키를 만들고, 값은 `0xABC` 포인터로 해줘"라는 뜻입니다. 'Key'는 별명일 뿐, 'Value'는 원본의 주소입니다.

##### 🌳 트리 쉐이킹 (Tree Shaking)

* `import/export`는 **'정적(Static)'**입니다. 코드를 실행하지 않고(정적 분석), '읽는 것'만으로도 누가 뭘 가져다 쓰는지 100% 파악할 수 있습니다.
* Webpack 같은 번들러는 이 정적 분석을 통해, `export`는 되었지만 앱 전체에서 단 한 번도 `import` 되지 않은 '죽은 코드(dead code)'를 식별하고, 최종 번들 파일에서 제거해버립니다.

---

#### ## 8. 기타 주요 용어 정리

* **스냅샷 (Snapshot):**
    * `Snap` (찰칵) + `Shot` (촬영) = "순간 촬영 사진".
    * Git `commit`이나 VM/DB 백업 등, **"지속적으로 변경되는 복잡한 시스템"**의 **"특정 시점의 상태"**를 통째로 '얼려서' 저장하는 개념을 의미합니다. Git은 '변경분(Diff)'이 아닌 '스냅샷'을 저장하기에 브랜치 전환이 빠릅니다.
* **정적 (Static) vs 동적 (Dynamic):**
    * **정적 (Static) / 컴파일 타임 / 빌드 타임:**
        * **언제:** 앱이 **"실행되기 전 (Before Runtime)"**.
        * **무엇을:** 코드 **'텍스트(Text)'** 그 자체.
        * **예시:** Webpack의 트리 쉐이킹, TypeScript의 타입 체크. 코드를 실행하지 않고 '읽기'만 해서 최적화하거나 에러를 잡습니다.
    * **동적 (Dynamic) / 런타임:**
        * **언제:** 앱이 **"실행되는 중 (During Runtime)"**.
        * **무엇을:** 메모리에 올라간 실제 '데이터'와 '객체'.
        * **예시:** `this` 바인딩. 코드가 '실행'되어 함수가 '호출'되는 그 순간의 '맥락'에 따라 `this`가 동적으로 결정됩니다.

---
